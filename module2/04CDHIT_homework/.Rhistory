source('~/code/thesis_R/install.R', echo=TRUE)
sequences<-generate.random.dna.sequences(10,4,4)
setwd("~/code/doc/bioinformaticscourse/module2/04CDHIT_homework")
generate.random.dna.sequences <- function(max.length, min.length, n){
sequences <- array()
if (max.length%%1!=0 || min.length%%1!=0 || n%%1!=0){
stop("all parameters must be integer")
}
if(max.length<min.length)
stop("maximum length must not be lower than minimum length")
for (i in 1:n){
sequence.size <- sample(min.length:max.length,1)
sequences[i] <- paste(sample(x = c("A", "C", "G", "T"), size = sequence.size, replace = T), sep = "", collapse = "")
}
return(sequences)
}
order.sequences.by.length <- function(seq){
return(seq[order(nchar(seq), seq, decreasing = T)])
}
sequences<-generate.random.dna.sequences(10,4,4)
sequences
ordered.sequences <- order.sequences.by.length(sequences)
ordered.sequences
library(data.table)
pkgTest("data.table")
pkgTest <- function(x){
if (!require(x,character.only = TRUE)){
install.packages(x,dep=TRUE)
if(!require(x,character.only = TRUE)) stop("Package not found")
}
}
pkgTest("data.table")
pkgTest("data.table")
library(data.table)
do.call(CJ, replicate(14, 0:1, FALSE))
CJ
generate.kmers.dictionary <- function(alphabet, k){
pkgTest("data.table")
library(data.table)
return(do.call(CJ, replicate(k, alphabet, FALSE)))
}
generate.kmers.dictionary(c("A", "C", "G", "T"),2)
generate.kmers.dictionary(c("A", "C", "G", "T"),3)
lookup.table <- generate.kmers.dictionary(c("A", "C", "G", "T"),3)
lookup.table[1]
lookup.table[2]
paste(lookup.table[2], sep = "", collapse = "")
paste(lookup.table, sep = "", collapse = "")
paste(lookup.table[2], sep = "", collapse = "")
apply(lookup.table,1,paste,collapse="")
generate.kmers.dictionary <- function(alphabet, k){
pkgTest("data.table")
library(data.table)
lookup.table <- do.call(CJ, replicate(k, alphabet, FALSE))
return(apply(lookup.table,1,paste,collapse=""))
}
lookup.table <- generate.kmers.dictionary(c("A", "C", "G", "T"),3)
lookup.table
k=3
lookup.table <- generate.kmers.dictionary(c("A", "C", "G", "T"),k)
a <- 1:5
a
length(a) <- 2
a
rep(1:4, 2)
rep(1:4, each = 2)       # not the same.
rep(1:4, c(2,2,2,2))     # same as second.
rep(1:4, c(2,1,2,1))
sequences
ordered.sequences
seq.a <- ordered.sequences[1]
seq.b <- ordered.sequences[2]
n <- min(c(length(seq.a), length(seq.b)))
length(seq.a) <- n
length(seq.b) <- n
seq.a
seq.b
n
n <- min(c(nchar(seq.a), nchar(seq.b)))
n
nchar(seq.a) <- n
nchar(seq.a)
substr(seq.a, 1, n)
seq.a <- substr(seq.a, 1, n)
seq.b <- substr(seq.b, 1, n)
seq.a
seq.b
seq.a <- substr(seq.a, 1, n)
seq.b <- substr(seq.b, 1, n)
for(i in 1:n-k+1){
seq.a.strings[i] <- substr(seq.a,i,i+k-1)
seq.b.strings[i] <- substr(seq.b,i,i+k-1)
}
seq.a.strings <- array()
seq.b.strings <- array()
for(i in 1:n-k+1){
seq.a.strings[i] <- substr(seq.a,i,i+k-1)
seq.b.strings[i] <- substr(seq.b,i,i+k-1)
}
seq.a.strings
seq.a
setwd("~/code/doc/bioinformaticscourse/module2/03hmm_homework/code")
x <- sample(1:5, 20, T)
y <- rnorm(20) + x
df <- data.frame(x = ordered(x), y = y)
df
factor(seq.a, levels = lookup.table)
seq.a.index <- factor(seq.a, levels = lookup.table)
seq.a.index
seq.a.index <- as.numeric(factor(seq.a, levels = lookup.table))
seq.a.index
seq.a.index <- as.numeric(factor(seq.a.strings, levels = lookup.table))
seq.a.index
lookup.table
seq.a.strings
as.numeric(factor("AAA", levels = lookup.table))
as.numeric(factor("GCC", levels = lookup.table))
seq.a.index <- as.numeric(factor(seq.a.strings, levels = lookup.table))
seq.a.intable <- as.numeric(factor(seq.a.strings, levels = lookup.table))
seq.b.intable <- as.numeric(factor(seq.b.strings, levels = lookup.table))
seq.a.intable <- as.numeric(factor(seq.a.strings, levels = lookup.table))
seq.b.intable <- as.numeric(factor(seq.b.strings, levels = lookup.table))
seq.a.intable==seq.b.intable
seq.a.intable
seq.b.intable
sum(seq.a.intable==seq.b.intable)
sum(c(T,T,T,F,F,T))
get.minimum.similarities <- function(L, K, p){
return(L - K + 1 - (1 - p) * K * L)
}
threshold <- 0.9
minimum.similarities <- get.minimum.similarities(n,k,threshold)
minimum.similarities
get.minimum.similarities <- function(L, K, p){
return(ceiling(L - K + 1 - (1 - p) * K * L))
}
minimum.similarities <- get.minimum.similarities(n,k,threshold)
minimum.similarities
kmers.comparisson <- function(seq.a, seq.b, k, threshold){
lookup.table <- generate.kmers.dictionary(c("A", "C", "G", "T"),k)
# truncate sequences to the shortest length
n <- min(c(nchar(seq.a), nchar(seq.b)))
seq.a <- substr(seq.a, 1, n)
seq.b <- substr(seq.b, 1, n)
seq.a.strings <- array()
seq.b.strings <- array()
for(i in 1:n-k+1){
seq.a.strings[i] <- substr(seq.a,i,i+k-1)
seq.b.strings[i] <- substr(seq.b,i,i+k-1)
}
seq.a.intable <- as.numeric(factor(seq.a.strings, levels = lookup.table))
seq.b.intable <- as.numeric(factor(seq.b.strings, levels = lookup.table))
similar.kmers <- sum(seq.a.intable==seq.b.intable)
minimum.similarities <- get.minimum.similarities(n,k,threshold)
return(similar.kmers >= minimum.similarities)
}
compare.sequences <- function(seq.a, seq.b, kmers, threshold){ # kmers is an array with all the "k" values to be evaluated (eg: 2-mers and 5-mers)
for (i in 1:length(kmers)){
kmers.similarities[i] <- kmers.comparisson(seq.a, seq.b, kmers[i], threshold) # store all evaluated similarities
}
return(all(kmers.similarities)) # return TRUE only if all similarities are true
}
N = length(ordered.sequences)
clusters    <- list()
clusters[1] <- 1 # Only the positions of the original ordered sequences are stored
for (j in 2:N){
are.similar.sequences = compare.sequences(ordered.sequences[clusters[1]], + #compare with cluster
ordered.sequences[j], +
c(2,5), +
threshold)
if(are.similar.sequences){
}
}
clusters    <- array()
clusters[1] <- 1 # Only the positions of the original ordered sequences are stored
for (j in 2:N){
are.similar.sequences = compare.sequences(ordered.sequences[clusters[1]], + #compare with cluster
ordered.sequences[j], +
c(2,5), +
threshold)
if(are.similar.sequences){
}
}
compare.sequences(seq.a, seq.b)
compare.sequences(seq.a, seq.b, 2, 0.9)
compare.sequences <- function(seq.a, seq.b, kmers, threshold){ # kmers is an array with all the "k" values to be evaluated (eg: 2-mers and 5-mers)
kmers.similarities <- array()
for (i in 1:length(kmers)){
kmers.similarities[i] <- kmers.comparisson(seq.a, seq.b, kmers[i], threshold) # store all evaluated similarities
}
return(all(kmers.similarities)) # return TRUE only if all similarities are true
}
compare.sequences(seq.a, seq.b, 2, 0.9)
compare.sequences(seq.a, seq.a , 2, 0.9)
compare.sequences(seq.a, seq.a , 2, 1)
compare.sequences(seq.a, seq.a , 2, 2)
compare.sequences(seq.a, seq.a , 2, 1)
N
clusters
for (j in 2:N){
are.similar.sequences = compare.sequences(ordered.sequences[clusters[1]], + #compare with cluster
ordered.sequences[j], +
c(2,5), +
threshold)
if(are.similar.sequences){
}
}
ordered.sequences[clusters[1]]
ordered.sequences[2]
are.similar.sequences = compare.sequences(ordered.sequences[clusters[1]], ordered.sequences[j], c(2,5), threshold)
j
2L
for (j in 2:N){
are.similar.sequences = compare.sequences(ordered.sequences[clusters[1]], ordered.sequences[j], c(2,5), threshold)
if(are.similar.sequences){
}
}
are.similar.sequences
i <- 1
qq <- array()
qq[3] <- 9
qq
uu <- 1:4
i<-1
while(i<=length(uu)){
length(uu)<-length(uu)-1
}
while(i<=length(uu)){
length(uu)<-length(uu)-1
i<-i+1
}
i
uu
uu <- 1:4
while(i<=length(uu)){
length(uu)<-length(uu)-1
i<-i+1
}
i
uu
non.evaluated.sequences <- 1:N
non.evaluated.sequences <- non.evaluated.sequences[-1]
non.evaluated.sequences
N = length(ordered.sequences)
clusters    <- array()
non.evaluated.sequences <- 1:N # Here we store the indexes of the sequences that haven't been evaluated
i <- 1
while(length(non.evaluated.sequences)>0){ # As long as we still have sequences to evaluate
clusters[i]<- non.evaluated.sequences[1] # store the first non-evaluated sequence as a new cluster
non.evaluated.sequences <- non.evaluated.sequences[-1] # and remove it from the sequences to be evaluated
sequence.labels <- array()
sequences.to.evaluate <- non.evaluated.sequences # this is to avoid the in-loop elimination to affect the loop's indexes
for (j in sequences.to.evaluate){ # every non-evaluated sequence
are.similar.sequences = compare.sequences(ordered.sequences[clusters[i]], ordered.sequences[j], c(2,5), threshold)
if(are.similar.sequences){
sequence.labels[j] <- i # assign the current cluster as label of the currently evaluated sequence
non.evaluated.sequences <- non.evaluated.sequences[-j] # remove this similar sequence from the sequences to be evaluated
} # don't do anything if evaluated sequences do not belong to the evaluated clusters
}
i <- i + 1
}
threshold <- 0.9
k.mers <- c(2,5)
cd.hit <- function(sequences, threshold, k.mers){
N = length(ordered.sequences)
clusters    <- array()
non.evaluated.sequences <- 1:N # Here we store the indexes of the sequences that haven't been evaluated
i <- 1
while(length(non.evaluated.sequences)>0){ # As long as we still have sequences to evaluate
clusters[i]<- non.evaluated.sequences[1] # store the first non-evaluated sequence as a new cluster
non.evaluated.sequences <- non.evaluated.sequences[-1] # and remove it from the sequences to be evaluated
sequence.labels <- array()
sequences.to.evaluate <- non.evaluated.sequences # this is to avoid the in-loop elimination to affect the loop's indexes
for (j in sequences.to.evaluate){ # every non-evaluated sequence
are.similar.sequences = compare.sequences(ordered.sequences[clusters[i]], ordered.sequences[j], k.mers, threshold)
if(are.similar.sequences){
sequence.labels[j] <- i # assign the current cluster as label of the currently evaluated sequence
non.evaluated.sequences <- non.evaluated.sequences[-j] # remove this similar sequence from the sequences to be evaluated
} # don't do anything if evaluated sequences do not belong to the evaluated clusters
}
i <- i + 1
}
return(list(clusters,sequence.labels))
}
cd.hit <- function(sequences, threshold, k.mers){
N = length(sequences)
clusters    <- array()
non.evaluated.sequences <- 1:N # Here we store the indexes of the sequences that haven't been evaluated
i <- 1
while(length(non.evaluated.sequences)>0){ # As long as we still have sequences to evaluate
clusters[i]<- non.evaluated.sequences[1] # store the first non-evaluated sequence as a new cluster
non.evaluated.sequences <- non.evaluated.sequences[-1] # and remove it from the sequences to be evaluated
sequence.labels <- array()
sequences.to.evaluate <- non.evaluated.sequences # this is to avoid the in-loop elimination to affect the loop's indexes
for (j in sequences.to.evaluate){ # every non-evaluated sequence
are.similar.sequences = compare.sequences(sequences[clusters[i]], sequences[j], k.mers, threshold)
if(are.similar.sequences){
sequence.labels[j] <- i # assign the current cluster as label of the currently evaluated sequence
non.evaluated.sequences <- non.evaluated.sequences[-j] # remove this similar sequence from the sequences to be evaluated
} # don't do anything if evaluated sequences do not belong to the evaluated clusters
}
i <- i + 1
}
return(list(clusters,sequence.labels))
}
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
cd.hit.results
ordered.sequences <- c(ordered.sequences, ordered.sequences)
cd.hit.results <- cd.hit(ordered.sequences, threshold, k.mers)
ordered.sequences
length(ordered.sequences)
ordered.sequences <- order.sequences.by.length(sequences)
function (x, ...)
UseMethod("print")
ordered.sequences <- order.sequences.by.length(sequences)
ordered.sequences <- c(ordered.sequences, ordered.sequences)
print("ordered sequences:")
print(ordered.sequences)
sequences<-generate.random.dna.sequences(10,4,4)
sequences <- c(sequences, sequences)
print("original sequences are:")
print(sequences)
ordered.sequences <- order.sequences.by.length(sequences)
print("ordered sequences:")
print(ordered.sequences)
threshold <- 0.9
k.mers <- c(2,5)
cd.hit.results <- cd.hit(ordered.sequences, threshold, k.mers)
cd.hit.results
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
print(seq.a, seq.b)
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
seq.a <- sequences[clusters[i]]
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
cd.hit.results
cd.hit.results[1]
cd.hit.results[2]
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
print("a", 1)
print("a", 4)
print(c("a", 2)
)
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
cd.hit.results
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
source('/media/fito/Windows/Users/fitoh/Documents/code/doc/bioinformaticscourse/module2/04CDHIT_homework/main.R')
